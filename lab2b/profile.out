Total: 524 samples
     368  70.2%  70.2%      524 100.0% thread_worker
      26   5.0%  75.2%       99  18.9% SortedList_insert
      17   3.2%  78.4%       56  10.7% SortedList_lookup
      15   2.9%  81.3%       15   2.9% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1734
       7   1.3%  82.6%        7   1.3% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:161
       6   1.1%  83.8%        6   1.1% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:239
       6   1.1%  84.9%        6   1.1% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1734
       5   1.0%  85.9%        5   1.0% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:165
       5   1.0%  86.8%        5   1.0% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:253
       4   0.8%  87.6%        4   0.8% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1734
       3   0.6%  88.2%        3   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:203
       3   0.6%  88.7%        3   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:211
       3   0.6%  89.3%        3   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:212
       3   0.6%  89.9%        3   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:225
       3   0.6%  90.5%        3   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:226
       3   0.6%  91.0%        3   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:239
       3   0.6%  91.6%        3   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1056
       3   0.6%  92.2%        3   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1734
       3   0.6%  92.7%        3   0.6% _init
       2   0.4%  93.1%        2   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:204
       2   0.4%  93.5%        2   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:263
       2   0.4%  93.9%        2   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:610
       2   0.4%  94.3%        2   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1150
       2   0.4%  94.7%        2   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1240
       2   0.4%  95.0%        2   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1328
       2   0.4%  95.4%        2   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1413
       2   0.4%  95.8%        2   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1733
       1   0.2%  96.0%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:205
       1   0.2%  96.2%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:232
       1   0.2%  96.4%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:236
       1   0.2%  96.6%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:237
       1   0.2%  96.8%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:238
       1   0.2%  96.9%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:243
       1   0.2%  97.1%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:256
       1   0.2%  97.3%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:263
       1   0.2%  97.5%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:265
       1   0.2%  97.7%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:266
       1   0.2%  97.9%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:300
       1   0.2%  98.1%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:442
       1   0.2%  98.3%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:527
       1   0.2%  98.5%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:969
       1   0.2%  98.7%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1235
       1   0.2%  98.9%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1324
       1   0.2%  99.0%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1415
       1   0.2%  99.2%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1417
       1   0.2%  99.4%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1593
       1   0.2%  99.6%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1709
       1   0.2%  99.8%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1721
       1   0.2% 100.0%        1   0.2% 0x00007ffe8fbc5600
       0   0.0% 100.0%      524 100.0% ?? /usr/src/debug////////glibc-2.17-c758a686/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:118
       0   0.0% 100.0%        1   0.2% __GI___clock_gettime
       0   0.0% 100.0%      524 100.0% start_thread
ROUTINE ====================== thread_worker in /u/cs/ugrad/eugenec/CS111/lab2b/lab2_list.c
   368    524 Total samples (flat / cumulative)
     .      .  323: }
     .      .  324: 
     .      .  325: 
     .      .  326: 
     .      .  327: 
---
     .      .  328: void* thread_worker(void* arg){
     .      .  329: 	int list_length = 0;
     .      .  330: 	int deleted = 0;
     .      .  331: 	int i = 0;
     .      .  332: 	int key_location = 0;
     .      .  333: 	struct timespec begin, end;
     .      .  334: 
     .      .  335: 	SortedListElement_t* elements_array_partition = arg;
     .      .  336: 	SortedListElement_t* lookup_ptr = NULL;
     .      .  337: 
     .      .  338: 
     .      .  339: 
     .      .  340: 	///// insertion /////
     .      .  341: 	for( ;i < iteration_ct;i++){ //inserts a partition of the elements array into the list
     .      .  342: 		
     .      .  343: 
     .      .  344: 		//essentially mods the key value with the number of lists to return back a list location to place the key.
     .      .  345: 		key_location = key_hash(elements_array_partition[i].key);
     .      .  346: 
     .      .  347: 
     .      .  348: 		if(sync_s == 1){
     .      .  349: 			if(clock_gettime(CLOCK_MONOTONIC, &begin) < 0){ //time a thread spends waiting before acquiring the lock
     .      .  350: 				fprintf(stderr, "Error: Could not set start time to variable begin. Exiting with error number: %d\n", 1);
     .      .  351: 				exit(1);
     .      .  352: 			}
   250    250  353: 			while(__sync_lock_test_and_set(&lock[key_location], 1));
     .      .  354: 			if(clock_gettime(CLOCK_MONOTONIC, &end) < 0){ //the time that is clocked in after the thread has acquired the lock
     .      .  355: 				fprintf(stderr, "Error: Could not set end time to variable end. Exiting with error number: %d\n", 1);
     .      .  356: 				exit(1);
     .      .  357: 			}
     .      .  358: 			sum_for_total_lock_acq_time(begin.tv_sec, end.tv_sec, begin.tv_nsec, end.tv_nsec);
     .      .  359: 
     .      .  360: 
     .     99  361: 			SortedList_insert(&dummy_head_list[key_location], &elements_array_partition[i]);
     .      .  362: 			__sync_lock_release(&lock[key_location]);
     .      .  363: 		}
     .      .  364: 
     .      .  365: 
     .      .  366: 		else if(sync_m == 1){
     .      .  367: 			if(clock_gettime(CLOCK_MONOTONIC, &begin) < 0){ //time a thread spends waiting before acquiring the lock
     .      .  368: 				fprintf(stderr, "Error: Could not set start time to variable begin. Exiting with error number: %d\n", 1);
     .      .  369: 				exit(1);
     .      .  370: 			}
     .      .  371: 
     .      .  372: 			if(pthread_mutex_lock(&mutex[key_location]) != 0){
     .      .  373: 				fprintf(stderr, "Error: Mutex failed to lock. Exiting with error number: %d\n", 1);
     .      .  374: 				exit(1);
     .      .  375: 			}
     .      .  376: 
     .      .  377: 			if(clock_gettime(CLOCK_MONOTONIC, &end) < 0){ //the time that is clocked in after the thread has acquired the lock
     .      .  378: 				fprintf(stderr, "Error: Could not set end time to variable end. Exiting with error number: %d\n", 1);
     .      .  379: 				exit(1);
     .      .  380: 			}
     .      .  381: 			
     .      .  382: 			sum_for_total_lock_acq_time(begin.tv_sec, end.tv_sec, begin.tv_nsec, end.tv_nsec);
     .      .  383: 
     .      .  384: 
     .      .  385: 
     .      .  386: 			SortedList_insert(&dummy_head_list[key_location], &elements_array_partition[i]);
     .      .  387: 			
     .      .  388: 			if(pthread_mutex_unlock(&mutex[key_location]) != 0){
     .      .  389: 				fprintf(stderr, "Error: Mutex failed to unlock. Exiting with error number: %d\n", 1);
     .      .  390: 				exit(1);
     .      .  391: 			}
     .      .  392: 		}
     .      .  393: 		else{
     .      .  394: 			SortedList_insert(&dummy_head_list[key_location], &elements_array_partition[i]);
     .      .  395: 		}
     .      .  396: 	}
     .      .  397: 
     .      .  398: 
     .      .  399: 
     .      .  400: 
     .      .  401: 
     .      .  402: 	///// finding list_length for each list /////
     .      .  403: 
     .      .  404: 	for(key_location = 0; key_location < list_num; key_location++){
     .      .  405: 		if(sync_s == 1){
     .      .  406: 			if(clock_gettime(CLOCK_MONOTONIC, &begin) < 0){ //time a thread spends waiting before acquiring the lock
     .      .  407: 				fprintf(stderr, "Error: Could not set start time to variable begin. Exiting with error number: %d\n", 1);
     .      .  408: 				exit(1);
     .      .  409: 			}
     2      2  410: 			while(__sync_lock_test_and_set(&lock[key_location], 1));
     .      .  411: 			if(clock_gettime(CLOCK_MONOTONIC, &end) < 0){ //the time that is clocked in after the thread has acquired the lock
     .      .  412: 				fprintf(stderr, "Error: Could not set end time to variable end. Exiting with error number: %d\n", 1);
     .      .  413: 				exit(1);
     .      .  414: 			}
     .      .  415: 			sum_for_total_lock_acq_time(begin.tv_sec, end.tv_sec, begin.tv_nsec, end.tv_nsec);
     .      .  416: 
     .      .  417: 
     .      .  418: 
     .      .  419: 
     .      .  420: 
     .      .  421: 			if((list_length = SortedList_length(&dummy_head_list[key_location])) < 0){
     .      .  422: 				fprintf(stderr, "Error: List length cannot be negative. Exiting with error number: %d\n", 2);
     .      .  423: 				exit(2);
     .      .  424: 			}
     .      .  425: 			__sync_lock_release(&lock[key_location]);
     .      .  426: 		}
     .      .  427: 
     .      .  428: 		else if(sync_m == 1){
     .      .  429: 			if(clock_gettime(CLOCK_MONOTONIC, &begin) < 0){ //time a thread spends waiting before acquiring the lock
     .      .  430: 				fprintf(stderr, "Error: Could not set start time to variable begin. Exiting with error number: %d\n", 1);
     .      .  431: 				exit(1);
     .      .  432: 			}
     .      .  433: 
     .      .  434: 			if(pthread_mutex_lock(&mutex[key_location]) != 0){
     .      .  435: 				fprintf(stderr, "Error: Mutex failed to lock. Exiting with error number: %d\n", 1);
     .      .  436: 				exit(1);
     .      .  437: 			}
     .      .  438: 
     .      .  439: 			if(clock_gettime(CLOCK_MONOTONIC, &end) < 0){ //the time that is clocked in after the thread has acquired the lock
     .      .  440: 				fprintf(stderr, "Error: Could not set end time to variable end. Exiting with error number: %d\n", 1);
     .      .  441: 				exit(1);
     .      .  442: 			}
     .      .  443: 			sum_for_total_lock_acq_time(begin.tv_sec, end.tv_sec, begin.tv_nsec, end.tv_nsec);
     .      .  444: 
     .      .  445: 
     .      .  446: 
     .      .  447: 			if((list_length = SortedList_length(&dummy_head_list[key_location])) < 0){
     .      .  448: 				fprintf(stderr, "Error: List length cannot be negative. Exiting with error number: %d\n", 2);
     .      .  449: 				exit(2);
     .      .  450: 			}
     .      .  451: 			if(pthread_mutex_unlock(&mutex[key_location]) != 0){
     .      .  452: 				fprintf(stderr, "Error: Mutex failed to unlock. Exiting with error number: %d\n", 1);
     .      .  453: 				exit(1);
     .      .  454: 			}
     .      .  455: 		}
     .      .  456: 
     .      .  457: 		else{
     .      .  458: 			if((list_length = SortedList_length(&dummy_head_list[key_location])) < 0){
     .      .  459: 				fprintf(stderr, "Error: List length cannot be negative. Exiting with error number: %d\n", 2);
     .      .  460: 				exit(2);
     .      .  461: 			}
     .      .  462: 		}
     .      .  463: 	}
     .      .  464: 
     .      .  465: 
     .      .  466: 
     .      .  467: 
     .      .  468: 
     .      .  469: 
     .      .  470: 
     .      .  471: 
     .      .  472: 
     .      .  473: 
     .      .  474: 
     .      .  475: 
     .      .  476: 	///// lookup and deletion for each list /////
     .      .  477: 	for(i = 0; i < iteration_ct; i++){
     .      .  478: 		key_location = key_hash(elements_array_partition[i].key);
     .      .  479: 		if(sync_s == 1){
     .      .  480: 			if(clock_gettime(CLOCK_MONOTONIC, &begin) < 0){ //time a thread spends waiting before acquiring the lock
     .      .  481: 				fprintf(stderr, "Error: Could not set start time to variable begin. Exiting with error number: %d\n", 1);
     .      .  482: 				exit(1);
     .      .  483: 			}
   116    116  484: 			while(__sync_lock_test_and_set(&lock[key_location], 1));
     .      1  485: 			if(clock_gettime(CLOCK_MONOTONIC, &end) < 0){ //the time that is clocked in after the thread has acquired the lock
     .      .  486: 				fprintf(stderr, "Error: Could not set end time to variable end. Exiting with error number: %d\n", 1);
     .      .  487: 				exit(1);
     .      .  488: 			}
     .      .  489: 			sum_for_total_lock_acq_time(begin.tv_sec, end.tv_sec, begin.tv_nsec, end.tv_nsec);
     .      .  490: 
     .      .  491: 
     .      .  492: 
     .      .  493: 
     .      .  494: 
     .      .  495: 
     .     56  496: 			lookup_ptr = SortedList_lookup(&dummy_head_list[key_location], elements_array_partition[i].key);
     .      .  497: 			if(lookup_ptr != NULL){
     .      .  498: 				if((deleted = SortedList_delete(lookup_ptr)) == 1){
     .      .  499: 					fprintf(stderr, "Error: Deletion failed. Exiting with error number: %d\n", 2);
     .      .  500: 					exit(2);
     .      .  501: 				}
     .      .  502: 			}
     .      .  503: 			else{
     .      .  504: 				fprintf(stderr, "Error: Element did not exist. Exiting with error number: %d\n", 2);
     .      .  505: 				exit(2);
     .      .  506: 			}
     .      .  507: 			__sync_lock_release(&lock[key_location]);
     .      .  508: 		}
     .      .  509: 
     .      .  510: 
     .      .  511: 		else if(sync_m == 1){
     .      .  512: 			if(clock_gettime(CLOCK_MONOTONIC, &begin) < 0){ //time a thread spends waiting before acquiring the lock
     .      .  513: 				fprintf(stderr, "Error: Could not set start time to variable begin. Exiting with error number: %d\n", 1);
     .      .  514: 				exit(1);
     .      .  515: 			}
     .      .  516: 
     .      .  517: 			if(pthread_mutex_lock(&mutex[key_location]) != 0){
     .      .  518: 				fprintf(stderr, "Error: Mutex failed to lock. Exiting with error number: %d\n", 1);
     .      .  519: 				exit(1);
     .      .  520: 			}
     .      .  521: 
     .      .  522: 			if(clock_gettime(CLOCK_MONOTONIC, &end) < 0){ //the time that is clocked in after the thread has acquired the lock
     .      .  523: 				fprintf(stderr, "Error: Could not set end time to variable end. Exiting with error number: %d\n", 1);
     .      .  524: 				exit(1);
     .      .  525: 			}
     .      .  526: 
     .      .  527: 			sum_for_total_lock_acq_time(begin.tv_sec, end.tv_sec, begin.tv_nsec, end.tv_nsec);
     .      .  528: 
     .      .  529: 
     .      .  530: 
     .      .  531: 
     .      .  532: 
     .      .  533: 
     .      .  534: 			lookup_ptr = SortedList_lookup(&dummy_head_list[key_location], elements_array_partition[i].key);
     .      .  535: 			if(lookup_ptr != NULL){
     .      .  536: 				if((deleted = SortedList_delete(lookup_ptr)) == 1){
     .      .  537: 					fprintf(stderr, "Error: Deletion failed. Exiting with error number: %d\n", 2);
     .      .  538: 					exit(2);
     .      .  539: 				}
     .      .  540: 			}
     .      .  541: 			else{
     .      .  542: 				fprintf(stderr, "Error: Element did not exist. Exiting with error number: %d\n", 2);
     .      .  543: 				exit(2);
     .      .  544: 			}
     .      .  545: 			if(pthread_mutex_unlock(&mutex[key_location]) != 0){
     .      .  546: 				fprintf(stderr, "Error: Mutex failed to unlock. Exiting with error number: %d\n", 1);
     .      .  547: 				exit(1);
     .      .  548: 			}
     .      .  549: 		}
     .      .  550: 
     .      .  551: 
     .      .  552: 		else{
     .      .  553: 			lookup_ptr = SortedList_lookup(&dummy_head_list[key_location], elements_array_partition[i].key);
     .      .  554: 			if(lookup_ptr != NULL){
     .      .  555: 				if((deleted = SortedList_delete(lookup_ptr)) == 1){
     .      .  556: 					fprintf(stderr, "Error: Deletion failed. Exiting with error number: %d\n", 2);
     .      .  557: 					exit(2);
     .      .  558: 				}
     .      .  559: 			}
     .      .  560: 			else{
     .      .  561: 				fprintf(stderr, "Error: Element did not exist. Exiting with error number: %d\n", 2);
     .      .  562: 				exit(2);
     .      .  563: 			}
     .      .  564: 		}
     .      .  565: 
     .      .  566: 	}
     .      .  567: 	return arg;
     .      .  568: }
---
     .      .  569: 
     .      .  570: 
     .      .  571: void sum_for_total_lock_acq_time(time_t tv_sec_begin, time_t tv_sec_end, long int tv_nsec_begin, long int tv_nsec_end){
     .      .  572: 	long long temp = 0;
     .      .  573: 	temp = (tv_sec_end - tv_sec_begin) * 1000000000L;
ROUTINE ====================== thread_worker in /u/cs/ugrad/eugenec/CS111/lab2b/lab2_list.c
   368    524 Total samples (flat / cumulative)
     .      .  323: }
     .      .  324: 
     .      .  325: 
     .      .  326: 
     .      .  327: 
---
     .      .  328: void* thread_worker(void* arg){
     .      .  329: 	int list_length = 0;
     .      .  330: 	int deleted = 0;
     .      .  331: 	int i = 0;
     .      .  332: 	int key_location = 0;
     .      .  333: 	struct timespec begin, end;
     .      .  334: 
     .      .  335: 	SortedListElement_t* elements_array_partition = arg;
     .      .  336: 	SortedListElement_t* lookup_ptr = NULL;
     .      .  337: 
     .      .  338: 
     .      .  339: 
     .      .  340: 	///// insertion /////
     .      .  341: 	for( ;i < iteration_ct;i++){ //inserts a partition of the elements array into the list
     .      .  342: 		
     .      .  343: 
     .      .  344: 		//essentially mods the key value with the number of lists to return back a list location to place the key.
     .      .  345: 		key_location = key_hash(elements_array_partition[i].key);
     .      .  346: 
     .      .  347: 
     .      .  348: 		if(sync_s == 1){
     .      .  349: 			if(clock_gettime(CLOCK_MONOTONIC, &begin) < 0){ //time a thread spends waiting before acquiring the lock
     .      .  350: 				fprintf(stderr, "Error: Could not set start time to variable begin. Exiting with error number: %d\n", 1);
     .      .  351: 				exit(1);
     .      .  352: 			}
   250    250  353: 			while(__sync_lock_test_and_set(&lock[key_location], 1));
     .      .  354: 			if(clock_gettime(CLOCK_MONOTONIC, &end) < 0){ //the time that is clocked in after the thread has acquired the lock
     .      .  355: 				fprintf(stderr, "Error: Could not set end time to variable end. Exiting with error number: %d\n", 1);
     .      .  356: 				exit(1);
     .      .  357: 			}
     .      .  358: 			sum_for_total_lock_acq_time(begin.tv_sec, end.tv_sec, begin.tv_nsec, end.tv_nsec);
     .      .  359: 
     .      .  360: 
     .     99  361: 			SortedList_insert(&dummy_head_list[key_location], &elements_array_partition[i]);
     .      .  362: 			__sync_lock_release(&lock[key_location]);
     .      .  363: 		}
     .      .  364: 
     .      .  365: 
     .      .  366: 		else if(sync_m == 1){
     .      .  367: 			if(clock_gettime(CLOCK_MONOTONIC, &begin) < 0){ //time a thread spends waiting before acquiring the lock
     .      .  368: 				fprintf(stderr, "Error: Could not set start time to variable begin. Exiting with error number: %d\n", 1);
     .      .  369: 				exit(1);
     .      .  370: 			}
     .      .  371: 
     .      .  372: 			if(pthread_mutex_lock(&mutex[key_location]) != 0){
     .      .  373: 				fprintf(stderr, "Error: Mutex failed to lock. Exiting with error number: %d\n", 1);
     .      .  374: 				exit(1);
     .      .  375: 			}
     .      .  376: 
     .      .  377: 			if(clock_gettime(CLOCK_MONOTONIC, &end) < 0){ //the time that is clocked in after the thread has acquired the lock
     .      .  378: 				fprintf(stderr, "Error: Could not set end time to variable end. Exiting with error number: %d\n", 1);
     .      .  379: 				exit(1);
     .      .  380: 			}
     .      .  381: 			
     .      .  382: 			sum_for_total_lock_acq_time(begin.tv_sec, end.tv_sec, begin.tv_nsec, end.tv_nsec);
     .      .  383: 
     .      .  384: 
     .      .  385: 
     .      .  386: 			SortedList_insert(&dummy_head_list[key_location], &elements_array_partition[i]);
     .      .  387: 			
     .      .  388: 			if(pthread_mutex_unlock(&mutex[key_location]) != 0){
     .      .  389: 				fprintf(stderr, "Error: Mutex failed to unlock. Exiting with error number: %d\n", 1);
     .      .  390: 				exit(1);
     .      .  391: 			}
     .      .  392: 		}
     .      .  393: 		else{
     .      .  394: 			SortedList_insert(&dummy_head_list[key_location], &elements_array_partition[i]);
     .      .  395: 		}
     .      .  396: 	}
     .      .  397: 
     .      .  398: 
     .      .  399: 
     .      .  400: 
     .      .  401: 
     .      .  402: 	///// finding list_length for each list /////
     .      .  403: 
     .      .  404: 	for(key_location = 0; key_location < list_num; key_location++){
     .      .  405: 		if(sync_s == 1){
     .      .  406: 			if(clock_gettime(CLOCK_MONOTONIC, &begin) < 0){ //time a thread spends waiting before acquiring the lock
     .      .  407: 				fprintf(stderr, "Error: Could not set start time to variable begin. Exiting with error number: %d\n", 1);
     .      .  408: 				exit(1);
     .      .  409: 			}
     2      2  410: 			while(__sync_lock_test_and_set(&lock[key_location], 1));
     .      .  411: 			if(clock_gettime(CLOCK_MONOTONIC, &end) < 0){ //the time that is clocked in after the thread has acquired the lock
     .      .  412: 				fprintf(stderr, "Error: Could not set end time to variable end. Exiting with error number: %d\n", 1);
     .      .  413: 				exit(1);
     .      .  414: 			}
     .      .  415: 			sum_for_total_lock_acq_time(begin.tv_sec, end.tv_sec, begin.tv_nsec, end.tv_nsec);
     .      .  416: 
     .      .  417: 
     .      .  418: 
     .      .  419: 
     .      .  420: 
     .      .  421: 			if((list_length = SortedList_length(&dummy_head_list[key_location])) < 0){
     .      .  422: 				fprintf(stderr, "Error: List length cannot be negative. Exiting with error number: %d\n", 2);
     .      .  423: 				exit(2);
     .      .  424: 			}
     .      .  425: 			__sync_lock_release(&lock[key_location]);
     .      .  426: 		}
     .      .  427: 
     .      .  428: 		else if(sync_m == 1){
     .      .  429: 			if(clock_gettime(CLOCK_MONOTONIC, &begin) < 0){ //time a thread spends waiting before acquiring the lock
     .      .  430: 				fprintf(stderr, "Error: Could not set start time to variable begin. Exiting with error number: %d\n", 1);
     .      .  431: 				exit(1);
     .      .  432: 			}
     .      .  433: 
     .      .  434: 			if(pthread_mutex_lock(&mutex[key_location]) != 0){
     .      .  435: 				fprintf(stderr, "Error: Mutex failed to lock. Exiting with error number: %d\n", 1);
     .      .  436: 				exit(1);
     .      .  437: 			}
     .      .  438: 
     .      .  439: 			if(clock_gettime(CLOCK_MONOTONIC, &end) < 0){ //the time that is clocked in after the thread has acquired the lock
     .      .  440: 				fprintf(stderr, "Error: Could not set end time to variable end. Exiting with error number: %d\n", 1);
     .      .  441: 				exit(1);
     .      .  442: 			}
     .      .  443: 			sum_for_total_lock_acq_time(begin.tv_sec, end.tv_sec, begin.tv_nsec, end.tv_nsec);
     .      .  444: 
     .      .  445: 
     .      .  446: 
     .      .  447: 			if((list_length = SortedList_length(&dummy_head_list[key_location])) < 0){
     .      .  448: 				fprintf(stderr, "Error: List length cannot be negative. Exiting with error number: %d\n", 2);
     .      .  449: 				exit(2);
     .      .  450: 			}
     .      .  451: 			if(pthread_mutex_unlock(&mutex[key_location]) != 0){
     .      .  452: 				fprintf(stderr, "Error: Mutex failed to unlock. Exiting with error number: %d\n", 1);
     .      .  453: 				exit(1);
     .      .  454: 			}
     .      .  455: 		}
     .      .  456: 
     .      .  457: 		else{
     .      .  458: 			if((list_length = SortedList_length(&dummy_head_list[key_location])) < 0){
     .      .  459: 				fprintf(stderr, "Error: List length cannot be negative. Exiting with error number: %d\n", 2);
     .      .  460: 				exit(2);
     .      .  461: 			}
     .      .  462: 		}
     .      .  463: 	}
     .      .  464: 
     .      .  465: 
     .      .  466: 
     .      .  467: 
     .      .  468: 
     .      .  469: 
     .      .  470: 
     .      .  471: 
     .      .  472: 
     .      .  473: 
     .      .  474: 
     .      .  475: 
     .      .  476: 	///// lookup and deletion for each list /////
     .      .  477: 	for(i = 0; i < iteration_ct; i++){
     .      .  478: 		key_location = key_hash(elements_array_partition[i].key);
     .      .  479: 		if(sync_s == 1){
     .      .  480: 			if(clock_gettime(CLOCK_MONOTONIC, &begin) < 0){ //time a thread spends waiting before acquiring the lock
     .      .  481: 				fprintf(stderr, "Error: Could not set start time to variable begin. Exiting with error number: %d\n", 1);
     .      .  482: 				exit(1);
     .      .  483: 			}
   116    116  484: 			while(__sync_lock_test_and_set(&lock[key_location], 1));
     .      1  485: 			if(clock_gettime(CLOCK_MONOTONIC, &end) < 0){ //the time that is clocked in after the thread has acquired the lock
     .      .  486: 				fprintf(stderr, "Error: Could not set end time to variable end. Exiting with error number: %d\n", 1);
     .      .  487: 				exit(1);
     .      .  488: 			}
     .      .  489: 			sum_for_total_lock_acq_time(begin.tv_sec, end.tv_sec, begin.tv_nsec, end.tv_nsec);
     .      .  490: 
     .      .  491: 
     .      .  492: 
     .      .  493: 
     .      .  494: 
     .      .  495: 
     .     56  496: 			lookup_ptr = SortedList_lookup(&dummy_head_list[key_location], elements_array_partition[i].key);
     .      .  497: 			if(lookup_ptr != NULL){
     .      .  498: 				if((deleted = SortedList_delete(lookup_ptr)) == 1){
     .      .  499: 					fprintf(stderr, "Error: Deletion failed. Exiting with error number: %d\n", 2);
     .      .  500: 					exit(2);
     .      .  501: 				}
     .      .  502: 			}
     .      .  503: 			else{
     .      .  504: 				fprintf(stderr, "Error: Element did not exist. Exiting with error number: %d\n", 2);
     .      .  505: 				exit(2);
     .      .  506: 			}
     .      .  507: 			__sync_lock_release(&lock[key_location]);
     .      .  508: 		}
     .      .  509: 
     .      .  510: 
     .      .  511: 		else if(sync_m == 1){
     .      .  512: 			if(clock_gettime(CLOCK_MONOTONIC, &begin) < 0){ //time a thread spends waiting before acquiring the lock
     .      .  513: 				fprintf(stderr, "Error: Could not set start time to variable begin. Exiting with error number: %d\n", 1);
     .      .  514: 				exit(1);
     .      .  515: 			}
     .      .  516: 
     .      .  517: 			if(pthread_mutex_lock(&mutex[key_location]) != 0){
     .      .  518: 				fprintf(stderr, "Error: Mutex failed to lock. Exiting with error number: %d\n", 1);
     .      .  519: 				exit(1);
     .      .  520: 			}
     .      .  521: 
     .      .  522: 			if(clock_gettime(CLOCK_MONOTONIC, &end) < 0){ //the time that is clocked in after the thread has acquired the lock
     .      .  523: 				fprintf(stderr, "Error: Could not set end time to variable end. Exiting with error number: %d\n", 1);
     .      .  524: 				exit(1);
     .      .  525: 			}
     .      .  526: 
     .      .  527: 			sum_for_total_lock_acq_time(begin.tv_sec, end.tv_sec, begin.tv_nsec, end.tv_nsec);
     .      .  528: 
     .      .  529: 
     .      .  530: 
     .      .  531: 
     .      .  532: 
     .      .  533: 
     .      .  534: 			lookup_ptr = SortedList_lookup(&dummy_head_list[key_location], elements_array_partition[i].key);
     .      .  535: 			if(lookup_ptr != NULL){
     .      .  536: 				if((deleted = SortedList_delete(lookup_ptr)) == 1){
     .      .  537: 					fprintf(stderr, "Error: Deletion failed. Exiting with error number: %d\n", 2);
     .      .  538: 					exit(2);
     .      .  539: 				}
     .      .  540: 			}
     .      .  541: 			else{
     .      .  542: 				fprintf(stderr, "Error: Element did not exist. Exiting with error number: %d\n", 2);
     .      .  543: 				exit(2);
     .      .  544: 			}
     .      .  545: 			if(pthread_mutex_unlock(&mutex[key_location]) != 0){
     .      .  546: 				fprintf(stderr, "Error: Mutex failed to unlock. Exiting with error number: %d\n", 1);
     .      .  547: 				exit(1);
     .      .  548: 			}
     .      .  549: 		}
     .      .  550: 
     .      .  551: 
     .      .  552: 		else{
     .      .  553: 			lookup_ptr = SortedList_lookup(&dummy_head_list[key_location], elements_array_partition[i].key);
     .      .  554: 			if(lookup_ptr != NULL){
     .      .  555: 				if((deleted = SortedList_delete(lookup_ptr)) == 1){
     .      .  556: 					fprintf(stderr, "Error: Deletion failed. Exiting with error number: %d\n", 2);
     .      .  557: 					exit(2);
     .      .  558: 				}
     .      .  559: 			}
     .      .  560: 			else{
     .      .  561: 				fprintf(stderr, "Error: Element did not exist. Exiting with error number: %d\n", 2);
     .      .  562: 				exit(2);
     .      .  563: 			}
     .      .  564: 		}
     .      .  565: 
     .      .  566: 	}
     .      .  567: 	return arg;
     .      .  568: }
---
     .      .  569: 
     .      .  570: 
     .      .  571: void sum_for_total_lock_acq_time(time_t tv_sec_begin, time_t tv_sec_end, long int tv_nsec_begin, long int tv_nsec_end){
     .      .  572: 	long long temp = 0;
     .      .  573: 	temp = (tv_sec_end - tv_sec_begin) * 1000000000L;
